/*=================================
■■■ 클래스 고급 ■■■
- 상속(Inheritance)
=================================*/

// - super

// static으로 선언되지 않은 메소드에서 사용되며
// 현재 클래스가 상속받은 상위 클래스의 객체를 가리킨다.
// super는 상위 클래스의 생성자를 호출하거나
// 상위 클래스의 멤버 변수 또는 메소드를 호출할 때 사용할 수 있다.

// 하위 클래스의 생성자에게 상위 클래스의 생성자를 호출할 때에는
// 하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다.

// - 생성자와 클래스 상속간의 관계

// 하위 클래스는 상위(부모) 클래스의 멤버를 상속받지만,
// 생성자는 상속 대상에서 제외된다.
// 그리고 하위(자식) 클래스 생성자를 호출할 때
// 자동으로 상위 클래스 생성자를 호출하게 된다.
// 이 때, 상위 클래스의 생성자는
// 인수가 없는 생성자(default 생성자 형태)가 호출된다.

// 상위 클래스 및 하위 클래스(즉, 상속관계에 있는 클래스)를 설계하는 과정에서
// 상위 클래스의 생성자를 정의하지(작성하지)않거나                            // -> 상위 클래스가 default 구문인 상황
// 인수가 없는 생성자만을 정의한(작성한) 경우
// 명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
// 아무런 문제가 발생하지 않지만
// 상위 클래스에 인자가 있는 생성자만 존재하는 경우 주의해야 한다.

/*
예를 들어 다음에서
class Aclass
{
	Aclass(int n)
	{
	}
}
class Bclass extends Aclass
{
	Bclass()
	{
		super();
		//부모(); -> Aclass();를 호출하는데 부모클래스에 없으므로 에러남.
	}
}
*/

// 하위 클래스만 Bclass의 생성자에서
// 명시적으로 Aclass의 생성자를 호출하지 않으면
// 자동으로 인자 없는 생성자를 호출한다.
// 하지만, Aclass에는 인자가 있는 생성자만 존재하고
// 인자가 없는 생성자는 존재하지 않기 때문에 에러 발생한다.
// 따라서 Bclass생성자의 선두에
// 다음처럼 명시적으로 상위클래스의 생성자 호출 구문을 작성해야 한다.

/*
예를 들어 다음에서
class Aclass
{
	Aclss(int n)
	{
	}
}
class Bclass extends Aclass
{
	Bclass()
	{
		super(10);    //인자있는 것을 넣어서 만들어야지 에러가 안남.
		...;
		...;

	}
}
*/

/*
- 상속 시 주의할 사항
	: 상위 클래스에서 선언된 멤버 변수의 이름과
	  하위 클래스에서 선언된 멤버 변수의 이름이 같으면
	  상위 클래스의 멤버 변수는 무시된다.
	  이 때, 상위 클래스의 멤버 변수를 사용하기 위해서는
	  super 키워드를 이용한다.

예를 들어 다음에서
class Aclass
{
	int n=10;
}
class Bclass extends Aclass
{
	Bclass()
	{
		int n=20;             //이럴 경우는 20이 출력 되지만, System.out.println(super.n);이라고 하면 10이 찍힌다.
	}
}


	  동일한 이름의 멤버 변수나 동일한 이름의 메소드가
	  한 클래스 안에 선언되거나 정의되는 경우 기본적으로 에러 발생한다.
	  단, 메소드의 경우에는 매개변수의 갯수나 타입이 다른 경우
	  에러 발생하지 않고 이들을 서로 다른 메소드로 취급하게 된다.

	  
예를 들어 다음에서
class Aclass
{
	void write()
	{
		...;
	}
}
class Bclass extends Aclass
{
	Bclass()
	{
		//void write() -> 부모클래스에서 상속받아 온 것
		//{
		//	...;
		//}
		
		//void write(int n);  -> 이 경우 메소드 오버로딩.
		//{
		//	...;
		//}

		//void wrtie() -> 이렇게 메소드를 똑같이 설정한 경우 부모클래스꺼와 덮어쓰기 됨.
		//{
		//	...;
		//}
	}
}
*/

//Rect112 클래스와 Circle112클래스의 부모 클래스
class SuperTest112
{
	protected double area;
	private String title;

	public SuperTest112()
	{
		System.out.println("SuperTest112... 인자 없는 생성자");
	}

	public SuperTest112(String title)
	{
		this.title = title;
		System.out.println("SuperTest112... 문자열을 넘겨받는 생성자");
	}

	public void write()
	{
		System.out.println(title + " - " + area);
	}
}

//SuperTest112 클래스를 상속받는 자식 클래스(단일 상속)
class Rect112 extends SuperTest112
{
	/*	//부모 클래스의 내용을 물려 받음
	protected double area;

	// - private 멤버는 접근 자체가 불가능해서 상속 받기 불가능
	private String title;

	// - 생성자는 상속대상에서 제외이기 때문에 상속 받기 불가능
	public SuperTest112()
	{
		System.out.println("SuperTest112... 인자 없는 생성자");
	}
	
	// - 생성자는 상속대상에서 제외이기 때문에 상속 받기 불가능
	public SuperTest112(String title)
	{
		this.title = title;
		System.out.println("SuperTest112... 문자열을 넘겨받는 생성자");
	}

	public void wrtie()
	{
		System.out.println(title + " - " + area);
	}
	*/

	private int w, h;

	public Rect112()
	{
		// super();   -> 자동 삽입
	}

	public void calc(int w, int h)
	{
		this.w = w;
		this.h = h;
		area = (double)this.w * this.h;   //부모로 부터 상속받은 area
		write();
	}
	
	@Override  // @(어노테이션,annotation) - metadata이고 JDK 1.5부터 가능, 자바한테까지 전달하는 주석(부모클래스에서 write메소드를 상속받았지만 새롭게 하겠다고 의식적으로 알려주는 것.
	public void write() //부모클래스에 상속받은 틀과 똑같을때 상속받은 거 말고 아래꺼로 새롭게 재정의 하겠다는 것 = 오버라이딩 -> 오버라이딩을 하게 되면 다시 원래의 부모클래스의 write()메소드로 갈 수 없음.
	//public void write(int x) -> 이렇게 쓰면 메소드 오버로딩
	{
		System.out.println("w : " + w + ", h : " + h);
		System.out.println("사각형 - " + area);
	}

	//- 메소드 오버라이딩(Method Overriding)
	//	: 상위 클래스를 상속받은 하위 클래스에서
	//    상위 클래스에 정의된 메소드를 다시 정의하는 것으로(재정의)
	//    객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//    재정의(Overriding)는 반드시 상속 관계에 있어야 하며,
	//    메소드 이름, 리턴 타입, 매개변수의 갯수나 타입이
	//    모두 완전히 일치해야 한다.
}

//SuperTest112 클래스를 상속받는 자식 클래스(단일 상속)
class Circle112 extends SuperTest112
{
	/*	//부모 클래스의 내용을 물려 받음
	protected double area;
	private String title;

	public SuperTest112()
	{
		System.out.println("SuperTest112... 인자 없는 생성자");
	}

	public SuperTest112(String title)
	{
		this.title = title;
		System.out.println("SuperTest112... 문자열을 넘겨받는 생성자");
	}

	public void wrtie()
	{
		System.out.println(title + " - " + area);
	}
	*/

	public Circle112(String title)
	{
		//super(); -> 아무것도 안 썼다면 자동 삽입
		super(title);
	}

	public void calc(int r)
	{
		area = r*r*3.141592;
		write();
	}
}

//------------------------------------------------------------------------------------

//main()메소드를 포함하는 외부의 다른 클래스
public class Test112
{
	public static void main(String[] args)
	{
		//Rect112 클래스(자식 클래스) 기반 인스턴스 생성
		Rect112 ob1 = new Rect112();
		//SuperTest112... 인자 없는 생성자

		//Circle112클래스 (자식 클래스) 기반 인스턴스 생성
		//Circle112 ob2 = new Circle112();
		//컴파일 에러
		//현재 Circle112 클래스에는
		//매개변수를 필요로하는 사용자정의 생성자가 만들어져 있으며
		//이로 인해 default 생성자가 자동으로 삽입되지 않는 상황.

		//Circle112 클래스(자식 클래스) 기반 인스턴스 생성
		Circle112 ob3 = new Circle112("원");
		//SuperTest112... 인자 없는 생성자
		//
		//SuperTest112... 문자열을 넘겨받는 생성자 -> super(title); 추가로 작성시 결과

		ob1.calc(10, 5);
		//w : 10, h : 5
		//사각형 - 50.0

		ob3.calc(10);
		//원 - 314.1592
	}
}

/*
============================================================================================================================================================
상위 클래스   | 하위 클래스        | 결과
------------------------------------------------------------------------------------------------------------------------------------------------------------
생성자를      |생성자 정의 안함    |-> 가능하다. (default 생성이 되어서 문제없다)
정의하지      |인수가 없는 생성자  |-> 가능하다. (default 생성이 되어서 문제없다)
않음          |인수가 있는 생성자  |-> 가능하다. (인수가 있는 생성자 안에서도 제일 먼저 호출)
------------------------------------------------------------------------------------------------------------------------------------------------------------
인수가        |생성자 정의 안함    |-> 가능하다.
없는          |인수가 없는 생성자  |-> 가능하다.
생성자만 정의 |인수가 있는 생성자  |-> 가능하다.
------------------------------------------------------------------------------------------------------------------------------------------------------------
인수가        |생성자 정의 안함    |-> 에러 발생.
있는          |인수가 없는 생성자  |-> 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생.(하위 클래스에서 상위 클래스의 인수가 있는 생성자를 넣어줘야됨)
생성자만 정의 |인수가 있는 생성자  |-> 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생.
============================================================================================================================================================
*/